# Лабораторная работа №4

Знакомство с основными средствами администрирования UNIX-подобных систем на примере дистрибутива Ubuntu Server.
Раскрытие команд командной оболочки. Часть 2.

## Рассматриваемые вопросы:

1. [Переменные командной строки](#1)
   - [Символ доллара `$`](#11)
   - [Зависимость от регистра](#12)
   - [Создание переменных](#13)
   - [Кавычки](#14)
   - [Команда `set`](#15)
   - [Команда `unset`](#16)
   - [Переменная окружения `$PS1`](#17)
   - [Переменная окружения `$PATH`](#18)
   - [Команда `env`](#19)
   - [Команда `export`](#110)
   - [Разграничения переменных](#111)
   - [Несвязанные переменные](#112)
2. [Встраивание и параметры командных оболочек](#2)
   - [Встраивание командных оболочек](#21)
   - [Параметры командной оболочки](#22)
3. [История команд командной оболочки](#3)
   - [Повторение последней выполненной команды](#31)
   - [Повторение других команд](#32)
   - [Команда `history`](#33)
   - [Команда `!n`](#34)
   - [Сочетание клавиш `Ctrl-r`](#35)
   - [Переменная окружения `$HISTSIZE`](#36)
   - [Переменная окружения `$HISTFILE`](#37)
   - [Переменная окружения `$HISTFILESIZE`](#38)
   - [Предотвращение сохранения команд](#39)
4. [Формирование списков имен файлов на основе шаблонов](#4)
   - [Звездочка `*`](#41)
   - [Знак вопроса `?`](#42)
   - [Квадратные скобки `[]`](#43)
   - [Диапазоны a-z и 0-9](#44)
   - [Переменная окружения `$LANG` и квадратные скобки](#45)
   - [Предотвращение формирования списков имен файлов на основе шаблонов](#46)

# Переменные командной строки <a name="1"></a>

## Символ доллара `$` <a name="11"></a>

Важным интерпретируемым командной оболочкой символом является символ доллара `$`. Командная оболочка будет искать переменную окружения с именем, соответствующим размещенной после символа доллара строке, и заменять данный символ и имя переменной на значение этой переменной (или ни на что в том случае, если переменной не существует).

> ### _Задание_:
>
> Выполните следующие команды. Скриншот вывода поместите в отчет.
>
> ```
> echo Это командная оболочка $SHELL
> echo Данная командная оболочка $SHELL используется на компьютере $HOSTNAME
> echo Идентификатор пользователя $USER равен $UID
> echo Моей домашней директорией является директория $HOME
> ```

## Зависимость от регистра <a name="12"></a>

Выполните следующие команды и убедитесь в том, что имена переменных командной оболочки зависят от регистра.

```
echo Привет $USER
echo Привет $user
```

## Создание переменных <a name="13"></a>

Пример создания переменной MyVar со значением 555:

```
MyVar = 555
echo $MyVar
```

> ### _Задание_:
>
> Создайте переменную, содержащую вашу фамилию. Выведите ее на экран. Скриншот вывода поместите в отчет.

## Кавычки <a name="14"></a>

Обратите внимание на то, что двойные кавычки также позволяют осуществлять раскрытие переменных в строке команды, в то время, как одинарные кавычки позволяют предотвратить такое раскрытие.

> ### _Задание_:
>
> Создайте переменную, содержащую название любого города. После этого выполните следующие команды. Скриншот вывода поместите в отчет.
>
> ```
> echo "Сейчас мы находимся в городе $city."
> echo ' Сейчас мы находимся в городе $city.'
> ```

## Команда `set` <a name="15"></a>

Вы можете использовать команду `set` для вывода списка переменных окружения. В системах Ubuntu и Debian команда `set` также выведет список функций командной оболочки после списка переменных командной оболочки. Поэтому для ознакомления со всеми элементами списка переменных окружения при работе с данными системами рекомендуется использовать команду `set | more`.

## Команда `unset` <a name="16"></a>

Следует использовать команду `unset` для удаления переменной из вашего окружения командной оболочки.

> ### _Задание_:
>
> Удалите ранее созданные переменные с вашей фамилией и выбранным названием города. Попробуйте вывести их значение на экран. Скриншот вывода поместите в отчет.

## Переменная окружения `$PS1` <a name="17"></a>

Переменная окружения `$PS1` устанавливает формат приветствия вашей командной оболочки. При вводе строки форматирования вы можете использовать обратный слэш для экранирования таких специальных символов, как символ `\u`, предназначенный для вывода имени пользователя, или `\w`, предназначенный для вывода имени рабочей директории. На странице руководства командной оболочки bash представлен полный список специальных символов.

Выполните следующие команды и наглядно ознакомьтесь с тем, как при изменении переменной окружения `$PS1` меняется формат приветствия вашей командной строки.

```
PS1=приглашение
PS1='приглашение '
PS1='> '
PS1='\u@\h$ '
PS1='\u@\h:\W$'
```

> ### _Задание_:
>
> Для того, чтобы избежать неисправимых ошибок, вы можете использовать зеленый цвет для приглашений командной оболочки, выводимых обычным пользователям, и красный цвет для приглашений командной оболочки, выводимых > пользователю root. Добавьте следующие строки в ваш файл .bashrc для использования зеленого цвета в приглашениях, выводимых обычным пользователям. Для правки файла .bashrc воспользуйтесь текстовыми редакторами nano или vim.
>
> ```
> # цветное приглашение командной оболочки
> RED='\[\033[01;31m\]'
> WHITE='\[\033[01;00m\]'
> GREEN='\[\033[01;32m\]'
> BLUE='\[\033[01;34m\]'
> export PS1="${debian_chroot:+($debian_chroot)}$GREEN\u$WHITE@$BLUE\h$WHITE\w\$ "
> ```

## Переменная окружения `$PATH` <a name="18"></a>

Переменная окружения `$PATH` устанавливает директории файловой системы, в которых командная оболочка ищет бинарные файлы, необходимые для исполнения команд (за исключением тех случаев, когда команда является встроенной или представлена псевдонимом команды). Данная переменная содержит список путей к директориям с символами двоеточия в качестве разделителей.

Командная оболочка не будет осуществлять поиск бинарных файлов, которые могут быть исполнены, в текущей директории. (Функция поиска исполняемых файлов в текущей директории являлась простейшим механизмом несанкционированного доступа к данным, хранящимся на компьютерах под управлением PC-DOS). В том случае, если вы хотите, чтобы командная оболочка осуществляла поиск исполняемых файлов в текущей директории, вам следует добавить символ . в конец строки, являющейся значением переменной `$PATH` вашей командной оболочки.

Значение переменной `$PATH` вашей командной оболочки может отличаться в случае использования команды `su`.

> ### _Задание_:
>
> 1. Выведите на экран содержимое переменной окружения `$PATH`.
> 2. Выполните команду `exit`.
> 3. Выполните команду `su`.
> 4. Выведите на экран содержимое переменной окружения `$PATH`.
> 5. Выполните команду `exit`.
> 6. В чем отличие содержимого переменной окружения `$PATH` разных режимов доступа? Ответ и скриншоты вывода пунктов 1 и 4 поместите в отчет.

## Команда `env` <a name="19"></a>

Команда `env` в случае использования без параметров выведет список экспортированных переменных окружения. Отличие данной команды от команды `set` с параметрами заключается в том, что команда `set` выводит список всех переменных окружения, включая те переменные, которые не экспортируются в дочерние командные оболочки.

Кроме того, команда `env` может также использоваться для запуска "чистой" командной оболочки (командной оболочки без наследования какого-либо окружения). Команда `env -i` позволяет очистить окружение дочерней командной оболочки.

Вы можете использовать команду `env` для установки значения переменной `$LANG` или любой другой переменной окружения одного экземпляра командной оболочки bash в рамках одной команды. 

## Команда `export` <a name="110"></a>

Вы можете экспортировать переменные командной оболочки в другие командные оболочки с помощью команды `export`. При помощи приведенных ниже команд осуществляется экспорт переменной окружения в дочерние командные оболочки. Выполните даныне команды, вывод команд `echo` поместите в отчет.

```
var3=три
var4=четыре
export var4
echo $var3 $var4
bash
echo $var3 $var4
```

При этом с помощью данной команды переменная не экспортируется в родительскую командную оболочку (ниже приведено продолжение предыдущего примера). Выполните даныне команды, вывод команд `echo` поместите в отчет.

```
export var5=пять
echo $var3 $var4 $var5
exit
echo $var3 $var4 $var5
```

## Разграничения переменных <a name="111"></a>

До текущего момента мы сталкивались с тем, что командная оболочка bash интерпретирует переменную начиная с символа доллара, продолжая интерпретацию до появления первого не алфавитно-цифрового символа, который не является символом подчеркивания. В некоторых ситуациях такое поведение может оказаться проблемой.

> ### _Задание_:
>
> Выполните следующие команды. Скриншот вывода поместите в отчет.
>
> ```
> prefix=Super
> echo Привет $prefixman и $prefixgirl
> echo Привет ${prefix}man и ${prefix}girl
> ```

## Несвязанные переменные <a name="112"></a>

В примере ниже представлена попытка вывода значения переменной `$MyVar`, но она не является успешной ввиду того, что переменной не существует. По умолчанию командная оболочка не будет выводить ничего в том случае, если переменная не связана (ее не существует). Выполните приведенную ниже команду и ознакомьтесь с выводом.

```
echo $MyVar
```

Однако, существует параметр командной оболочки `nounset`, который вы можете использовать для генерации ошибки в том случае, если используемой переменной не существует. Выполните приведенный ниже пример и ознакомьтесь с выводом.

```
set -u
echo $Myvar
set +u
echo $Myvar
```

В командной оболочке bash команда `set -u` идентична команде `set -o nounset` и, по аналогии, команда `set +u` идентична команде `set +o nounset`.

# Встраивание и параметры командных оболочек <a name="2"></a>

## Встраивание командных оболочек <a name="21"></a>

Командные оболочки могут подвергаться встраиванию в рамках строк команд или, другими словами, в ходе разбора строк команд могут создаваться новые процессы, являющиеся копиями процесса текущей командной оболочки. Вы можете использовать переменные для доказательства факта создания новых командных оболочек. В примере ниже переменная `$var1` существует исключительно в рамках дочерней (временной) командной оболочки. Убедитесь в этом, выполнив приведенный пример.

```
echo $var1
echo $(var1=5;echo $var1)
echo $var1
```

Вы можете осуществлять встраивание командной оболочки в рамках уже встроенной командной оболочки, причем сам описанный процесс называется многоуровневым встраиванием командных оболочек.

> ### _Задание_:
>
> Руководствуясь примером выше, осуществите двухуровневое встраивание командных оболочек. Скриншот вывода поместите в отчет.

### Обратные кавычки

Однократное встраивание командной оболочки может оказаться полезным в том случае, если необходимо избежать изменения текущей директории. В примере ниже для встраивания командной оболочки используются обратные кавычки вместо рассмотренного ранее символа доллара со скобками.

```
echo `cd /etc; ls -d * | grep pass`
```

Вы можете использовать нотацию `$()` при необходимости осуществления многоуровневого встраивания командных оболочек, так как эту задачу невозможно решить с помощью обратных кавычек.

### Обратные кавычки или одинарные кавычки

Размещение встраиваемых команд между обратными кавычками вместо круглых скобок со знаком доллара позволяет отказаться от использования одного дополнительного символа. Однако, следует быть очень осторожным, так как обратные кавычки часто путают с одинарными кавычками. В техническом плане различия между кавычками ' и ` являются значительными.

## Параметры командной оболочки <a name="22"></a>

И команда `set`, и команда `unset` являются встроенными командами командной оболочки. Они могут использоваться для установки значений параметров самой командной оболочки bash. Проясним это утверждение, рассмотрев следующий пример. По умолчанию командная оболочка будет рассматривать неустановленные переменные как переменные, не имеющие ассоциированных значений. После установки значения параметра `-u` командная оболочка будет рассматривать любые обращения к неустановленным переменным как ошибки. Обратитесь к странице руководства для командной оболочки bash для получения дополнительной информации.

```
echo $var123
set -u
echo $var123
set +u
echo $var123
```

> ### _Задание_:
>
> Для вывода списка всех параметров вашей командной оболочки с установленными значениями следует использовать команду `echo $-`. Выполните пример, приведенный выше, но после каждой установки параметров командной оболочки выведите список всех ее параметров. Скриншот вывода поместите в отчет.

# История команд командной оболочки <a name="3"></a>

## Повторение последней выполненной команды <a name="31"></a>

Для повторения последней выполненной команды в командной оболочке bash следует использовать команду `!!`. Данная последовательность символов носит имя bang-bang.

## Повторение других команд <a name="32"></a>

Вы можете повторить другие команды, воспользовавшись символом `!`, после которого должен быть введен один или несколько начальных символов команды. В результате командная оболочка повторит последнюю команду, начинающуюся с введенных символов.

## Команда `history` <a name="33"></a>

Для просмотра списка исполненных ранее команд следует использовать команду `history`, которая позволяет вывести информацию об истории команд, выполненных в рамках данной командной оболочки (или использовать команду `history n` для ознакомления со списком из n последних выполненных команд).

> ### _Задание_:
>
> Выведите на экран список из 15 последних выполненных команд. Скриншот вывода поместите в отчет.

## Команда `!n` <a name="34"></a>

При вводе символа `!` с последующим вводом номера команды для повторения, командная оболочка выведет строку соответствующей команды и исполнит ее.

## Сочетание клавиш `Ctrl-r` <a name="35"></a>

Другой вариант методики осуществления поиска в истории команд заключается в использовании сочетания клавиш `ctrl-r`.

## Переменная окружения `$HISTSIZE` <a name="36"></a>

Переменная `$HISTSIZE` устанавливает количество команд, которые будут сохраняться при работе в вашем текущем окружении. Большинство дистрибутивов устанавливает стандартное значение данной переменной, равное 500 или 1000.

Вы можете изменить значение данной переменной на любое желаемое.

> ### _Задание_:
>
> Измените значение переменной окружения `$HISTSIZE` на 1500. Выведите ее значение на экран. Скриншот вывода поместите в отчет.

## Переменная окружения `$HISTFILE` <a name="37"></a>

Переменная `$HISTFILE` указывает на файл, который содержит данные истории команд вашей командной оболочки. В командной оболочке bash стандартным значением данной переменной является путь к файлу ~/.bash_history.
Данные истории команд для сессии работы с командной оболочкой сохраняются в данном файле в момент, когда вы завершаете сессию.

## Переменная окружения `$HISTFILESIZE` <a name="38"></a>

Количество команд, сохраняемых в вашем файле истории команд, может быть установлено с помощью переменной окружения` $HISTFILESIZE`.

## Предотвращение сохранения команд <a name="39"></a>

Вы можете предотвратить запись команды в файл истории, использовав пробел в качестве префикса команды.

> ### _Задание_:
>
> Выполните пару любых команд с предотвращением сохранения и пару без. Проверьте, что команды с пробелом в качестве префикса не сохранились. Скриншот поместите в отчет.

# Формирование списков имен файлов на основе шаблонов <a name="4"></a>

## Звездочка `*` <a name="41"></a>

Звездочка `*` интерпретируется командной оболочкой как символ для генерации списка имен файлов, причем сам символ звездочки может преобразовываться в любую комбинацию символов (или даже в строку без символов). В том случае, если не задано пути к директории для формирования списка имен файлов, командная оболочка будет использовать имена файлов из текущей директории. Обратитесь к странице руководства glob(7) для получения дополнительной информации.

Пример:

```
user@hostname:~$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
user@hostname:~$ ls File*
File4  File55  FileA  Fileab  FileAB
user@hostname:~$ ls file*
file1  file2  file3  fileab  fileabc
user@hostname:~$ ls *ile55
File55
user@hostname:~$ ls F*ile55
File55
user@hostname:~$ ls F*55
File55
```

## Знак вопроса `?` <a name="42"></a>

Аналогично звездочке, знак вопроса `?` интерпретируется командной оболочкой как символ для генерации списка имен файлов, причем сам знак вопроса соответствует ровно одному символу имени файла.

Пример:

```
user@hostname:~$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
user@hostname:~$ ls File?
File4  FileA
user@hostname:~$ ls Fil?4
File4
user@hostname:~$ ls Fil??
File4  FileA
user@hostname:~$ ls File??
File55  Fileab  FileAB
```

## Квадратные скобки `[]` <a name="43"></a>

Открывающаяся квадратная скобка `[` интерпретируется командной оболочкой как символ для генерации списка имен файлов, соответствующий любым из символов, находящихся между символом `[` и первым следующим за ним символом `]`. Порядок следования символов в списке между скобками не имеет значения. Каждая пара символов скобок заменяется ровно на один символ.

Пример:

```
user@hostname:~$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
user@hostname:~$ ls File[5A]
FileA
user@hostname:~$ ls File[A5]
FileA
user@hostname:~$ ls File[A5][5b]
File55
user@hostname:~$ ls File[a5][5b]
File55  Fileab
user@hostname:~$ ls File[a5][5b][abcdefghijklm]
ls: невозможно получить доступ к File[a5][5b][abcdefghijklm]: Нет такого файла или каталога
user@hostname:~$ ls file[a5][5b][abcdefghijklm]
fileabc
```

Также с помощью символа восклицательного знака `!` вы можете исключать символы из списка, расположенного между квадратными скобками. Кроме того, у вас имеется возможность создания комбинаций из описанных выше шаблонов.

Пример:

```
user@hostname:~$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
user@hostname:~$ ls file[a5][!Z]
fileab
user@hostname:~$ ls file[!5]*
file1  file2  file3  fileab  fileabc
user@hostname:~$ ls file[!5]?
fileab
```

## Диапазоны a-z и 0-9 <a name="44"></a>

Командная оболочка bash также распознает объявления диапазонов символов между квадратными скобками.

Пример:

```
user@hostname:~$ ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
user@hostname:~$ ls file[a-z]*
fileab  fileab2  fileabc
user@hostname:~$ ls file[0-9]
file1  file2  file3
user@hostname:~$ ls file[a-z][a-z][0-9]*
fileab2
```

## Переменная окружения `$LANG` и квадратные скобки <a name="45"></a>

В ходе работы с командной оболочкой не стоит забывать о влиянии на процесс генерации имен файлов значения переменной окружения `$LANG`. Причина этого влияния заключается в том, что в некоторых языках строчные буквы включаются в диапазон прописных букв (и наоборот).

Пример:

```
user@hostname:~$ ls [A-Z]ile?
file1  file2  file3  File4
user@hostname:~$ ls [a-z]ile?
file1  file2  file3  File4
user@hostname:~$ echo $LANG
en_US.UTF-8
user@hostname:~$ LANG=C
user@hostname:~$ echo $LANG
C
user@hostname:~$ ls [a-z]ile?
file1  file2  file3
user@hostname:~$ ls [A-Z]ile?
File4
```

В том случае, если в вашей системе устанавливается значение переменной окружения `$LC_ALL`, оно также должно быть сброшено для осуществления корректной генерации списков имен файлов.

> ## _Задание_:
>
> 1. Создайте 10 различных файлов с произвольными названиями (на ваше усмотрение).
> 2. При помощи символов звездочки \*, вопроса ?, и квадратных скобок [] продемонстируйте умение генерировать список имен файлов.
> 3. Скриншот вывода поместите в отчет.

## Предотвращение формирования списков имен файлов на основе шаблонов <a name="46"></a>

Формирование списков имен файлов на основе шаблонов может быть предотвращено путем помещения специальных символов в кавычки, а также экранирования этих символов при помощи обратного слэша `\`.
