# Лабораторная работа №5

Знакомство с основными средствами администрирования UNIX-подобных систем на примере дистрибутива Ubuntu Server.
Программные каналы и команды.

## Рассматриваемые вопросы:

1. [Перенаправление потоков ввода/вывода](#1)
    - [Потоки данных `stdin`, `stdout` и `stderr`](#11)
    - [Перенаправление стандартного потока вывода](#12)
        * [Операция перенаправления потока данных `stdout` (`>`)](#121)
        * [Содержимое выходного файла удаляется](#122)
        * [Параметр командной оболочки `noclobber`](#123)
        * [Нейтрализация влияния параметра командной оболочки `noclobber`](#124)
        * [Оператор дополнения `>>`](#125)
    - [Перенаправление стандартного потока ошибок](#13)
        * [Операция перенаправления потока данных `stderr` (`2>`)](#131)
        * [Операция перенаправления нескольких потоков данных `2>&1`](#132)
    - [Перенаправление стандартного потока вывода и программные каналы](#14)
    - [Перенаправление стандартного потока ввода](#15)
        * [Структура `< here document`](#151)
2. [Фильтры](#2)
    - [Фильтр `cat`](#21)
    - [Фильтр `tee`](#22)
    - [Фильтр `grep`](#23)
    - [Фильтр `tr`](#24)

# Перенаправление потоков ввода/вывода <a name="1"></a>

Одной из мощных возможностей командной оболочки системы Unix является механизм перенаправления потоков ввода/вывода с возможностью задействования программных каналов.

## Потоки данных `stdin`, `stdout` и `stderr` <a name="11"></a>
Командная оболочка `bash` поддерживает три типа базовых потоков данных; она принимает данные из стандартного потока ввода `stdin` (поток 0), отправляет данные в стандартный поток вывода `stdout` (поток 1), а также отправляет сообщения об ошибках в стандартный поток ошибок `stderr` (поток 2).

Приведенная ниже иллюстрация является графической интерпретацией этих трех потоков данных.

Клавиатура обычно служит источником данных для стандартного потока ввода `stdin`, в то время, как стандартные потоки вывода `stdout` и ошибок `stderr` используются для вывода данных. Новых пользователей Linux может смущать подобное разделение, так как не существует очевидного способа дифференцирования стандартных потоков вывода `stdout` и ошибок `stderr`. Опытные же пользователи знают о том, что разделение стандартных потоков вывода и ошибок может оказаться весьма полезным.

![bash_error_redirection_ru.png](pics/bash_ioredirection_keyboard_display_ru.png)

## Перенаправление стандартного потока вывода <a name="12"></a>

### Операция перенаправления потока данных `stdout` (`>`) <a name="121"></a>

Перенаправление стандартного потока вывода `stdout` может быть осуществлено с помощью символа знака "больше". В том случае, если при разборе строки команды командная оболочка обнаруживает символ знака `>`, она удаляет данные из файла и перенаправлет данные из стандартного потока вывода в него.

![bash_error_redirection_ru.png](pics/bash_output_redirection_ru.png)

Нотация `>` фактически является аббревиатурой для `1>` (в данном случае стандартный поток вывода обозначается как поток номер 1).

> ### _Задание_:
> 
> 1. Напечатайте текст в файл при помощи перенаправления потока вывода:
> 
> ``` bash
> echo Сегодня холодно! > winter.txt
> ```
>
> 2. Выведите содержимое файла winter.txt и проверьте выполнение пункта 1. Скриншот вывода поместите в отчет.

Обратите внимание на то, что командная оболочка `bash` фактически удаляет описание операции перенаправления потока данных из строки команды перед исполнением этой команды, представленной аргументом 0. Это значит, что в случае исполнения данной команды:

``` bash
echo привет > greetings.txt
```

командная оболочка будет рассматривать только два аргумента (echo = аргумент 0, привет = аргумент 1). Описание операции перенаправления потока данных удаляется перед началом подсчета количества аргументов.

### Содержимое выходного файла удаляется <a name="122"></a>

В том случае, если в процессе разбора строки команды командная оболочка обнаружит символ знака `>`, содержимое указанного после него файла будет удалено! Ввиду того, что описанная процедура выполняется перед извлечением аргумента 0, содержимое файла будет удалено даже в случае неудачного исполнения команды!

> ### _Задание_:
> 
> 1. Попробуйте напечатать текст в файл при заранее неправильной команды:
> 
> ``` bash
> zcho Сегодня холодно! > winter.txt
> ```
>
> 2. Выведите содержимое файла winter.txt. Скриншот вывода поместите в отчет.

### Параметр командной оболочки `noclobber` <a name="123"></a>

Удаление содержимого файла при использовании оператора `>` может быть предотвращено путем установки параметра командной оболочки `noclobber`.

> ### _Задание_:
> 
> Выполните следующие комнады и проанализируйте назначение параметра `noclobber`.
> 
> ``` bash
> set -o noclobber
> echo Сегодня холодно! > winter.txt
> set +o noclobber
> ```

### Нейтрализация влияния параметра командной оболочки `noclobber` <a name="124"></a>

Влияние параметра командной оболочки `noclobber` может быть нейтрализовано с помощью оператора `>|`.

> ### _Задание_:
> 
> 1. Установите параметр noclobber:
>
> ``` bash
> set -o noclobber
> ```
>
> 2. Напечатайте текст в файл с помощью оператора `>|`:
>
> ``` bash
> echo Сегодня холодно! >| winter.txt
> ```
>
> 3. Установите параметр noclobber в обратное положение:
>
> ``` bash
> set +o noclobber
> ```
>
> 4. Выведите содержимое файла winter.txt и проверьте выполнение пункта 2. Скриншот вывода поместите в отчет.

### Оператор дополнения `>>` <a name="125"></a>

Следует использовать оператор `>>` для записи данных из стандартного потока вывода в конец файла без предварительного удаления содержимого этого файла.

> ### _Задание_:
> 
> 1. Напечатайте ваше ФИО в файл winter.txt без предварительного удаления содержимого этого файла (`>>`). 
> 2. Выведите содержимое файла winter.txt и проверьте выполнение пункта 1. Скриншот вывода поместите в отчет.

## Перенаправление стандартного потока ошибок <a name="13"></a>

### Операция перенаправления потока данных `stderr` (`2>`) <a name="131"></a>

Перенаправление стандартного потока ошибок осуществляется с помощью оператора `2>`. Такое перенаправление может оказаться очень полезным для предотвращения заполнения вашего экрана сообщениями об ошибках.

![bash_error_redirection_ru.png](pics/bash_error_redirection_ru.png)

В примере ниже показана методика перенаправления данных из стандартного потока вывода в файл, а данных из стандартного потока ошибок - в специальный файл устройства `/dev/null`. Запись `1>` идентична записи `>`.

``` bash
find / > allfiles.txt 2> /dev/null [paul@RHELv4u3 ~]$
```

### Операция перенаправления нескольких потоков данных `2>&1` <a name="132"></a>

Для перенаправления данных как из стандартного потока вывода, так и из стандартного потока ошибок в один и тот же файл следует использовать конструкцию `2>&1`.

``` bash
find / > allfiles_and_errors.txt 2>&1
```

## Перенаправление стандартного потока вывода и программные каналы <a name="14"></a>

По умолчанию вы не можете использовать утилиту `grep` для обработки данных стандартного потока ошибок `stderr` приложения при использовании программных каналов в рамках строки команды, так как данная утилита получает данные исключительно из стандартного потока вывода `stdout` приложения.

С помощью конструкции `2>&1` вы можете переправить данные из стандартного потока ошибок `stderr` в стандартный поток вывода `stdout` приложения. Это обстоятельство позволяет обрабатывать передаваемые посредством программного канала данные из обоих потоков.

> ### _Задание_:
> 
> 1. Выполните следующую команду и проанализируйте выводимые сообщения об ошибках:
>
> ``` bash
> rm file42 file33 file1201 | grep file42
> ```
>
> 2. Выполните следующую команду и проанализируйте выводимое сообщение об ошибке:
>
> ``` bash
> rm file42 file33 file1201 2>&1 | grep file42
> ```
>
> 3. В чем различие двух команд? Ответ поместите в отчет.

## Перенаправление стандартного потока ввода <a name="15"></a>

Операция перенаправления потока данных `stdin` (`<`)

Перенаправление стандартного потока ввода `stdin` осуществляется с помощью оператора `<` (являющегося краткой версией оператора `0<`).

### Структура `< here document` <a name="151"></a>

Структура `here document` (иногда называемая структурой here-is-document) является механизмом для ввода данных до момента обнаружения определенной последовательности символов (обычно EOF). Маркер EOF может быть либо введен вручную, либо вставлен автоматически при нажатии комбинации клавиш Ctrl-D.

> ### _Задание_:
> 
> 1. Создайте текстовый файл text.txt и напечатайте в него свои ФИО при помощи следующей команды (после ококнчания печати напишите команду EOF):
>
> ``` bash
> cat <<EOF > text.txt
> ```
>
> 2. Выведите содержимое файла text.txt и проверьте выполнение пункта 1. Скриншот вывода поместите в отчет.

# Фильтры <a name="2"></a>

Команды, которые были реализованы для использования совместно с программными каналами, называются фильтрами. Эти фильтры реализуются в виде простейших программ, которые крайне эффективно выполняют одну определенную задачу. Исходя из всего вышесказанного, они могут использоваться в качестве строительных блоков при создании сложных конструкций.

## Фильтр `cat` <a name="21"></a>

При размещении фильтра `cat` между двумя программными каналами не будет осуществляться какой-либо обработки передающихся через них данных (за исключением передачи этих данных из стандартного потока ввода `stdin` в стандартный поток вывода `stdout` фильтра).

## Фильтр `tee` <a name="22"></a>

Создание сложных конвейеров при работе с интерфейсом командной строки системы Unix является занимательным процессом, но иногда вам могут потребоваться промежуточные результаты работы конвейера. Это именно тот случай, когда фильтр `tee` может оказаться очень полезным. Фильтр `tee` перемещает данные из стандартного потока ввода `stdin` в стандартный поток вывода `stdout`, а также записывает их в файл. Исходя из вышесказанного, фильтр tee функционирует аналогично фильтру `cat`, за исключением того, что он имеет два идентичных вывода.

> ### _Задание_:
> 
> 1. Создайте текстовый файл count.txt со следующим наполнением:
> 
> ``` bash 
> один
> два
> три
> четыре
> пять
> ```
>
> 2. Выполните следующую команду: 
> 
> ``` bash
> tac count.txt | tee temp.txt | tac
> ```
> 
> 3. Выведите содержимое файла temp.txt. Скриншот вывода поместите в отчет.

## Фильтр `grep` <a name="23"></a>

Фильтр `grep` снискал известность среди пользователей систем Unix. Наиболее простым сценарием использования фильтра `grep` является фильтрация строк текста, содержащих (или не содержащих) определенную подстроку.

> ### _Задание_:
> 
> 1. Создайте текстовый файл `tennis.txt` со следующим наполнением:
> 
> ``` bash
> Amelie Mauresmo, Fra
> Kim Clijsters, BEL
> Justine Henin, Bel
> Serena Williams, usa
> Venus Williams, USA
> ```
>
> 2. Выполните следующую команду: 
> 
> ``` bash
> cat tennis.txt | grep Williams
> ```
> 
> 3. Вы можете выполнить эту же задачу без задействования фильтра `cat`:
> 
> ``` bash
> grep Williams tennis.txt
> ```
>
> 4. Одним из наиболее полезных параметров фильтра grep является параметр `grep -i`, который позволяет производить фильтрацию строк без учета регистра:
> 
> ``` bash
> grep Bel tennis.txt 
> grep -i Bel tennis.txt 
> ```
>
> 5. Другим полезным параметром является параметр `grep -v`, который позволяет осуществлять вывод строк, не содержащих заданную строку:
> 
> ``` bash
> grep -v Fra tennis.txt 
> ```
>
> 6. И, конечно же, оба описанных выше параметра могут комбинироваться для фильтрации всех строк без учета регистра и вывода тех из них, которые не содержат заданной строки:
> 
> ``` bash
> grep -vi usa tennis.txt  
> ```
>
> 7. Скриншоты вывода пунктов 2-6 поместите в отчет.

## Фильтр `tr` <a name="24"></a>
Вы можете преобразовывать символы с помощью фильтра `tr`.

> ### _Задание_:
> 
> 1. Процедура преобразования всех обнаруженных в потоке данных символов `e` в символы `E`:
> 
> ``` bash
> cat tennis.txt | tr 'e' 'E'
> ```
> 
> 2. В данном случае осуществляется перевод всех буквенных символов в верхний регистр:
> 
> ``` bash
> cat tennis.txt | tr 'a-z' 'A-Z'
> ```
>
> 3. Параметр `tr -d` используется для удаления заданного символа:
> 
> ``` bash
> cat tennis.txt | tr -d e 
> ```
>
> 4. Скриншоты вывода пунктов 1-3 поместите в отчет.