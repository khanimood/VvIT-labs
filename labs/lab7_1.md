# Лабораторная работа №7.1

Знакомство с основными средствами администрирования UNIX-подобных систем на примере дистрибутива Ubuntu Server.
Сценарии

# Введение в разработку сценариев

Командные оболочки, такие, как bash и Korn shell поддерживают программные конструкции, которые могут быть сохранены в форме сценариев. Эти сценарии, в свою очередь, впоследствии могут использоваться в качестве реализаций дополнительных команд командной оболочки. Многие команды Linux реализованы в форме сценариев. Например, сценарии для обслуживания профиля пользователя исполняются при входе пользователя в систему, а сценарии инициализации - при остановке и запуске демона.

## Hello world

По аналогии с практически любым курсом по программированию, начнем работу с разработки сценария hello_world. Полученный сценарий будет выводить строку Hello World (по аналогии с нижеприведенной командой).

```
echo Hello World
```

> ## _Задание_:
>
> 1. Создайте простой сценария в редакторе vim, поместите в него вышеприведенную строку. Название сценария `hello_world`.
> 2. Выполните команду `chmod +x hello_world` для того, чтобы сделать файл сценария исполняемым. В том случае, если вы не будете добавлять путь к директории с вашими сценариями в список директорий из переменной окружения `PATH`, вам придется вводить полный путь к сценарию для того, чтобы командная оболочка смогла найти его.
> 3. Выполните сценарий при помощи команды `./hello_world`. Скриншот вывода поместите в отчет.

## She-bang

Вы ни при каких обстоятельствах не можете быть уверены в том, какая командная оболочка используется в системе пользователя. Сценарий, превосходно работающий в командной оболочке bash, может не работать в командных оболочках ksh, csh или dash. Для того, чтобы проинструктировать командную оболочку о необходимости запуска вашего сценария в определенной командной оболочке, вы должны начинать ваш сценарий с последовательности символов she-bang, после которой должен располагаться путь к бинарному файлу командной оболочки, в которой сценарий должен исполняться.

> ## _Задание_:
>
>  Доработайте ваш сценарий, разместив строку `#!/bin/bash` в начале. Последовательность символов `#!` называется she-bang (или иногда sha-bang), причем слово she-bang составлено из названий двух первых символов сценария. Теперь ваш сценарий будет исполняться в командной оболочке bash (к тому же, данный сценарий теперь можно называть bash-скриптом).

## Комментарий

> ## _Задание_:
>
>  Добавьте в ваш bash-скрипт пару комментариев (их содержание остается на авше усмотрение). Символ, обозначающий коментарий, это символ решетки `#`. Скриншот получившегося сценария поместите в отчет.

## Переменные

Ниже приведен простой пример объявления переменной в сценарии.

```
#!/bin/bash
#
# простая переменная в сценарии
#
var1=4
echo var1 = $var1
```

Сценарии могут содержать переменные, но ввиду того, что сценарии исполняются в своих собственных экземплярах командных оболочек, переменные не смогут пережить момент завершения исполнения сценария.

> ## _Задание_:
>
> 1. Создайте bash-скрипт с использованием переменных по аналогии с примером выше. Название сценария `var_script`.
> 2. Сделайте ваш скрипт исполняемым и выполните его, выведите значение используемой в нем переменной (его не будет).

Имеется возможность исполнения сценария в той же рабочей командной оболочке, данная техника называется использованием рабочей командной оболочки (sourcing a script).

> ## _Задание_:
>
> Выполните ваш сценарий `var_script` при помощи команды `source ./var_script` и выведите значение используемой в нем переменной. Скриншот вывода поместите в отчет.
> Вместо приведенной выше команды для использования рабочей командной оболочки можно использовать команду `. ./var_script`.

## Отладка сценария

Другой способ исполнения сценария в отдельной командной оболочке заключается во вводе команды `bash` перед именем сценария, которое в этом случае будет передаваться бинарному файлу командной оболочки в качестве параметра.

Дополнение данной команды до формы `bash -x` позволит вам ознакомиться со всеми командами, исполняемыми командной оболочкой (после раскрытия команд).

> ## _Задание_:
>
> Выполните ваш сценарий `var_script` при помощи команды `bash -x var_script`. Скриншот вывода поместите в отчет.
> 
> Обратите внимание на отсутствие строки комментария (первым символом которой является символ `#`), а также замену значения переменной перед исполнением команды для вывода данных `echo`.


# control structures в сценариях

## Команда `test []`

Команда `test` позволяет установить, является ли какое-либо выражение истинным или ложным. Начнем с проверки, больше ли целочисленное значение 10 целочисленного значения 55:

```
test 10 -gt 55 ; echo $?
```

> ## _Задание_:
>
> Какой вывод выдает команда в примере выше? Ответ поместить в отчет.

Команда `test` возвращает значение `1`, если выражение является ложным. И, как в следующем примере, команда `test` будет возвращать значение `0`, если выражение будет являться истинным.

```
test 56 -gt 55 ; echo $?
```

Для того, чтобы работать со строками `true` (истина) и `false` (ложь), можно использовать команду `test` таким образом, как показано ниже:

```
test 56 -gt 55 && echo true || echo false
test 6 -gt 55 && echo true || echo false
```

Команда `test` также может заменяться квадратными скобками, поэтому команды из примера ниже полностью аналогичны командам из примера выше.

```
[ 56 -gt 55 ] && echo true || echo false
[ 6 -gt 55 ] && echo true || echo false
```

Ниже приведены примеры реализаций некоторых проверок. Обратитесь к странице руководства `man test` для ознакомления с дополнительными возможностями реализации различных проверок.

```
[ -d foo ]             Существует ли директория foo ?
[ -e bar ]             Существует ли файл bar ?
[ '/etc' = $PWD ]      Эквивалентна ли строка /etc значению переменной $PWD ?
[ $1 != 'secret' ]     Отличается ли значение первого параметра сценария от строки secret ?
[ 55 -lt $bar ]        Меньше ли целочисленное значение 55 значения переменной $bar ?
[ $foo -ge 1000 ]      Является ли значение переменной $foo большим или равным целочисленному значению 1000 ?
[ "abc" < $bar ]       Будет ли строка abc расположена выше значения переменной $bar в списке после сортировки ?
[ -f foo ]             Является ли foo обычным файлом ?
[ -r bar ]             Является ли bar читаемым файлом ?
[ foo -nt bar ]        Новее ли файл foo файла bar ?
[ -o nounset ]         Активирован ли параметр командной оболочки nounset ?
```

## Условный переход `if then else`

Конструкция `if then else` предназначена для выбора варианта кода. В том случае, если определенное условие выполняется, будет исполняться какой либо код, в противном случае будет исполняться какой-либо другой код. В примере ниже осуществляется проверка существования файла, после чего в том случае, если предположение о существовании файла подтверждается, осуществляется вывод соответствующего сообщения.

```
#!/bin/bash

if [ -f isit.txt ]
then echo файл isit.txt существует!
else echo файл isit.txt не найден!
fi
```

> ## _Задание_:
>
> 1. Создайте скрипт с вышеприведенным кодом и сделайте его исполняемым. Название скрипта `choise`.
> 2. Выполните скрипт.
> 3. Создайте файл `isit.txt` и выполните скрипт еще раз.
> 4. Поместите скриншот вывода пунктов 2 и 3 в отчет.

## Условный переход `if then elif`

Вы можете разместить новый оператор условного перехода `if` внутри блока `else`, воспользовавшись оператором `elif`. Ниже приведен простой пример такой записи:

```
#!/bin/bash
count=42
if [ $count -eq 42 ]
then
  echo "42 является корректным значением."
elif [ $count -gt 42 ]
then
  echo "Слишком много."
else
  echo "Не достаточно."
fi
```

## Цикл `for`

В примере ниже представлен синтаксис классического цикла `for` в командной оболочке bash:

```
for i in 1 2 4
do
   echo $i
done
```

## Цикл `while`

Ниже приведен простой пример использования цикла `while`:

```
i=100;
while [ $i -ge 0 ] ;
do
   echo Обратный отсчет от 100 до 0, текущее значение $i;
   let i--;
done
```

## Цикл `until`
Ниже приведен простой пример использования цикла `until`:

```
let i=100;
until [ $i -le 0 ] ;
do
   echo Обратный отсчет от 100 до 1, текущее значение $i;
   let i--;
done
```

> ## _Задание_:
>
> Вычислите сумму ряда чисел от a до b. Например от 1 до 10:
>
> sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
> 
> Числа a и b будут переданы строкой на stdin, и разделены пробелом. Ответ необходимо вывести в stdout.
>
> Для чтения переменных, переданных на стандартный ввод используйте конструкцию `read -r a b`.
>
> Для получения последовательности чисел от a до b используйте конструкцию `$(eval echo {$a..$b})`.
>
> Проверочные данные на вход: `11 97`. Проверочные данные на выходе: `4698`.
> 
> Листинг скрипта и скриншот вывода поместите в отчет.